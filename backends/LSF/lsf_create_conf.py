from sys import *
import xml.dom.minidom
from urllib2 import Request, urlopen
from lxml import etree
import getopt
import traceback
import re
import cx_Oracle #@UnresolvedImport
from ConfigParser import ConfigParser, NoSectionError
config_file = "/etc/lsf.config"

def main():
    if not checkUsage():
        exit(0)
    readConfiguration()
    validateXML()
    parseCloudmanXML()
    banner = printBanner()
    #parseLsfEgoShared(LSFSHARECONF_FILE)
    #getTotalLsfSi2k()
    #parseLsfConfFile()
    try:
        filename
        output_file = open(filename , 'w')
    except NameError:
        output_file = stdout
        pass
    if command.lower() =='host':        
#        pass
        print >>output_file ,banner,generateHostPartition(),generateHostGroup()
    elif command.lower() =='user':
        #pass
        print >>output_file ,banner,genUserGroupHeader(),genAdminUserGroup(),genUserGroupExt(),genUserGroupStatic()
        print >>output_file ,genSubGroupShare(),genUserGroupFooter(),genMaxJobPerUser()
    else:
        showHelp()

def parseLsfConfFile():
    global LSF_BINDIR
    handle = open(LSFCONF,"r")
    alllines = handle.readlines()    
    for line in alllines:
        if re.search('LSF_BINDIR', line):
            str_array = line.split("=")
            LSF_BINDIR = str_array[1]
    handle.close()     
    

##get the total si2k by running LSf command
'''
p = subprocess.Popen(['/bin/ls','-ltr'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
while(True):
        retcode = p.poll() #returns None while subprocess is running
        line = p.stdout.readline()
        print  line
        if(retcode is not None):
               break
'''
def getTotalLsfSi2k():
    handle = open('/etc/lshosts',"r")
    alllines = handle.readlines()
    total_si2k = 0
    for line in alllines:
        if not matchPatternArrayinStr(LSFHOST_MATCH_STR,line):
            continue
        line = re.sub(' +',' ',line)
        str_array  = line.split(" ")
        if len(str_array) >2:
            model =  str_array[2]
            if model in lsf_model_spec:
                total_si2k += float(lsf_model_spec[model])
            else:
                print >>stderr,'model %s si2k not found' %model
        else:
            print >>stderr ,'Unable to determine model name from line %s generated by lshosts command' %line
    return 2 * total_si2k
        
def matchPatternArrayinStr(pattern_array,msg):
    for pattern in pattern_array:
        if re.search(pattern, msg, re.IGNORECASE):
            return True
    return False
    

       
def parseLsfEgoShared(lsf_shared_file):
    global lsf_model_spec
    lsf_model_spec ={}
    handle = open(lsf_shared_file,"r")
    alllines = handle.readlines()
    start_reg_exp = re.compile('Begin\s+HostModel',re.IGNORECASE)
    end_reg_exp = re.compile('End\s+HostModel',re.IGNORECASE)
    core_regex = re.compile("((\s+)(?P<core>\d+?)(\s+)cores(\s+)per(\s+)box)")
    parseLine=False
    for line in alllines:
        if re.match('#' ,line):##ignore the commented Line
            continue
        elif end_reg_exp.match(line):##stop parsing if the line contains End HostModel
            return
        elif start_reg_exp.match(line):##parse the line after this line
            parseLine=True
        elif parseLine:#parse the line if Start tag has been encountered
            str_array = line.split('#')
            if len(str_array) <2:
                print >>stderr,'Wrong line format[%s] in %s' %(line,lsf_shared_file)
                continue           
            model_spec_str = re.sub(' +',' ',str_array[0])
            comment = str_array[1]
            model_spec_array = model_spec_str.split(' ')            
            if len(model_spec_array) < 2:
                print >>stderr,'Wrong line format[%s] in %s' %(line,lsf_shared_file)
                continue
            model,spec,tmp  =  model_spec_array
            core_match = core_regex.search(comment)
            num_core = 2 #default number of core
            try:
                num_core =  core_match.groupdict()['core']
            except:
                print stderr ,'Wrong line format[%s] in %s' %(line,lsf_shared_file)
            lsf_model_spec[model] = (float(spec) * float(num_core) *1000)/2
            


#generate maximum job per user
def genMaxJobPerUser():
    begin ='''\n\nBegin User
USER_NAME   MAX_JOBS   JL/P   MAX_PEND_JOBS\n'''
    middle ='default     -          -      %s' %MAX_PENDING
    end ='\nEnd User'
    return begin + middle + end
 

#generate the LSFSUBGROUP share inside the LSFGROUP
##calculate the subgroupfraction takinf into the account resolution
##Normalize the share among the subgroup Lets say in a group only 90% is allocated then we will normalize it
#among the subgroups of the group
def genSubGroupShare():
    begin = '\n# user share definition inside their groups\n'
    middle =''
    for group in lsf_group:
        subgrp_list = ''
        subgrp_share_list = ''        
        total_share =0
        for subgroup in lsf_group[group]:
            total_share += float(lsf_group[group][subgroup]['SUBGROUPSHARE'])
        for subgroup in lsf_group[group]:
            subgrp_list += subgroup + ' '
            share_fraction = 100*(float(lsf_group[group][subgroup]['SUBGROUPSHARE'])/total_share)
            subgroupshare_fraction = int(share_fraction*float(SUBGROUP_SHARE_RESOLUTION) + 0.5)
            if subgroupshare_fraction==0:
                subgroupshare_fraction = SUBGROUP_SHARE_RESOLUTION             
            if len(lsf_group[group]) == 1:
                subgrp_share_list += '[default,%s] ' %SUBGROUP_SHARE_RESOLUTION
            else:
                subgrp_share_list += '[%s,%s] ' %(subgroup,subgroupshare_fraction)            
        middle += '\n%s\t(%s)\t(%s)' %(group,subgrp_list.strip(),subgrp_share_list.strip())
    return begin + middle
    


##generate the admin UserGroup for LSF
def genAdminUserGroup():
    return '%s\t(%s)\t()\n' %(LSF_ADMIN_GROUP,LSF_ADMIN_USER,)

##LSF SUBGROUP whose usergroup are resolved externally
def genUserGroupExt():
    begin ='\n# groups to be resolved by the external egroups\n'
    middle =''
    for group in lsf_group:
        for subgroup,subgrp_info in lsf_group[group].items():
            user_list = subgrp_info['USER_LIST']
            if user_list=='':
                middle += "\n%s\t(!)\t([default 1])" %subgroup
    return begin + middle

##LSF SUBGROUP whose usergroup are statically define
def genUserGroupStatic():
    begin ='\n\n#groups with special users\n'
    middle =''
    for group in lsf_group:
        for subgroup,subgrp_info in lsf_group[group].items():
            user_list = subgrp_info['USER_LIST']
            if user_list != '':
                middle += "\n%s\t(%s)\t([default 1])" %(subgroup,user_list)
    return begin + middle

    



def genUserGroupFooter():
    footer ='\nEnd UserGroup'
    return footer

def genUserGroupHeader():
    header = '''\nBegin UserGroup
GROUP_NAME    GROUP_MEMBER   USER_SHARES\n'''
    return header

def generateHostGroup():
    try:        
        connectDB()
        cursor.execute("SELECT DISTINCT resources FROM VWLSFCLIENTS WHERE lsfcluster = '%s' AND hostname <> 'loadbalancer' order by resources"%LSF_CLUSTER)
        result_set = cursor.fetchall()
        hostlist =[]
        for row in  result_set:
            hostname_aray = re.sub(' +',' ',row[0]).split(" ")
            for hostname in hostname_aray:
                hostlist.append(HOSTNAME_PREPEND+hostname)
        hostlist = list(set(hostlist))
        begin = 'Begin HostGroup\nGROUP_NAME    GROUP_MEMBER      # Key words\n'
        middle =''
        for host in hostlist:
            middle += '%s\t\t(!)\n'%host
        end ='End HostGroup\n\n'
        return begin+middle+end
    except Exception:
        print >>stdout,traceback.format_exc()
        print >>stdout ,'Error in Getting the HostGroup from LSF Database Check the Database'
    
    disconnectDB()
    

def validateXML():
    if dontvalidate:
        return    
    req = Request(LSFXSDDATA_URL)
    try:
        f = urlopen(req)
        xsdstr = f.read()
        schema_root = etree.XML(xsdstr)
        schema = etree.XMLSchema(schema_root)
        parser = etree.XMLParser(schema = schema)
        etree.parse(LSFDATA_URL, parser )
    except Exception :
        print >>stdout,traceback.format_exc()
        print >>stdout ,'It seems XML generated from Cloudman is not valid!!!'
        exit(0)
                               
  

def generateHostPartition():
    hostpartstr = ''
    for partition,groupshare_dict in partition_share.items():
        lsfhostname = HOSTNAME_PREPEND +partition.lower()
        begin = 'Begin HostPartition \nHPART_NAME = %s\nHOSTS      = %s\nUSER_SHARES = ( \\ \n' %(partition,lsfhostname)
        middle =''
        for group,share in groupshare_dict.items():
            middle +='  [%s,%s]  \\ \n' %(group,share) 
        end  = ')\nEnd HostPartition\n\n'
        hostpartstr += begin + middle + end
    return hostpartstr

def parseCloudmanXML():
    global partition_share,lsf_group
    partition_share = {}
    lsf_group ={}
    try:
        url = urlopen(LSFDATA_URL)
    except:
        print >> stdout, "URL:%s is not working see if the LSFDATA_URL is correct in File:%s" %(LSFDATA_URL,config_file)
        exit()
    doc = xml.dom.minidom.parse(url)
    ##Loop through all the project in the XML
    for project_node in doc.getElementsByTagName("PROJECT"):
        project_name = project_node.getAttribute("NAME")
        if project_name != LSFPROJECT_NAME:
            continue
        #loop through all the Top_level_allocation in the Project
        for tp_alloc_node in project_node.getElementsByTagName("TOP_LEVEL_ALLOCATION"):
            #loop through all the project allocation under this top_level_allocation
            for prj_alloc_node in  tp_alloc_node.getElementsByTagName("PROJECT_ALLOCATION"):
                #loop through all the group_allocation in this project_allocation
                grp_alloc_node_all = prj_alloc_node.childNodes[0]
                for grp_alloc_node in  grp_alloc_node_all.childNodes:
                    ##Check if this is elementNode
                    if grp_alloc_node.nodeType == grp_alloc_node.ELEMENT_NODE:
                        ##get all the 2nd Child of the group allocation nodes that is child 1 
                        ##here get only the metadata for the group_allocation
                        metadata_node = grp_alloc_node.childNodes[1]                                                
                        group_name = grp_alloc_node.getAttribute('NAME')
                        for metadata in metadata_node.getElementsByTagName("METADATA"):                            
                            if metadata.getAttribute("NAME") == 'HOSTPARTITION':
                                hostpartition = metadata.getAttribute("VALUE")
                                ##Round the ksi2k to nearest integer
                                share = int(float(grp_alloc_node.getAttribute('KSI2K'))+0.5)
                                if hostpartition in partition_share:
                                    partition_share[hostpartition][group_name] = share
                                else:
                                    partition_share[hostpartition] = {group_name:share}                                
                        ##here get all the Subgroup allocation for this Group
                        for subgrp_node in grp_alloc_node.getElementsByTagName("GROUP_ALLOCATION"):                            
                            ##normalize the subgroup-Share among the Group
                            subgroupshare = subgrp_node.getAttribute('KSI2K')
                            subgrp_metadata_node = subgrp_node.childNodes[1]
                            user_list=''
                            user_list_static = None
                            user_list_ldap = None
                            for metadata in subgrp_metadata_node.getElementsByTagName("METADATA"):                                    
                                if metadata.getAttribute("NAME") == 'USER_LIST':
                                    user_list_static = metadata.getAttribute("VALUE")                                    
                                elif metadata.getAttribute("NAME") == 'USER_LIST_LDAP':                                    
                                    user_list_ldap = metadata.getAttribute("VALUE")                                                                    
                            if user_list_ldap is not None:
                                user_list = user_list_ldap
                            elif user_list_static is not None:
                                user_list = user_list_static
                            subgroup =  subgrp_node.getAttribute("NAME")
                            if group_name in lsf_group:
                                lsf_group[group_name][subgroup]={'USER_LIST':user_list,'SUBGROUPSHARE':subgroupshare}
                            else:
                                lsf_group[group_name] = {subgroup:{'USER_LIST':user_list,'SUBGROUPSHARE':subgroupshare}}

def readConfiguration():
    global LSFCONF, LSFDATA_URL,LSFXSDDATA_URL, LSFPROJECT_NAME, HOSTNAME_PREPEND,LSF_DB_NAME,LSF_DB_USER,LSF_DB_PASSWORD
    global LSF_CLUSTER,LSF_ADMIN_GROUP,LSF_ADMIN_USER,MAX_JOB,MAX_PENDING,SUBGROUP_SHARE_RESOLUTION,LSFSHARECONF_FILE
    global LSFHOST_MATCH_STR
    config = ConfigParser()
    if not config.read([config_file]):
        print >> stdout,"Could not read lsf backend config file : %s"%config_file
        exit(0)        
    try:
        LSFCONF = config.get('lsf', 'LSFCONF')
        LSFDATA_URL = config.get('lsf', 'LSFDATA_URL')
        LSFXSDDATA_URL = config.get('lsf', 'LSFXSDDATA_URL')
        LSFPROJECT_NAME = config.get('lsf', 'LSFPROJECT_NAME')
        HOSTNAME_PREPEND= config.get('lsf', 'HOSTNAME_PREPEND')
        LSF_DB_NAME= config.get('lsf', 'LSF_DB_NAME')
        LSF_DB_USER= config.get('lsf', 'LSF_DB_USER')
        LSF_DB_PASSWORD= config.get('lsf', 'LSF_DB_PASSWORD')
        LSF_CLUSTER= config.get('lsf', 'LSF_CLUSTER')
        LSF_ADMIN_GROUP = config.get("lsf_admin","LSF_ADMIN_GROUP")
        LSF_ADMIN_USER = config.get("lsf_admin","LSF_ADMIN_USER") 
        MAX_JOB = config.get("lsf_job","MAX_JOB")
        MAX_PENDING = config.get("lsf_job","MAX_PENDING")
        SUBGROUP_SHARE_RESOLUTION = config.get("lsf","SUBGROUP_SHARE_RESOLUTION")
        LSFSHARECONF_FILE = config.get("lsf","LSFSHARECONF_FILE")
        LSFHOST_MATCH_STR = eval(config.get("lsf","LSFHOST_MATCH_STR"),{},{})
    except NoSectionError, e:
        raise Exception(e)
    
#This will connect to the DB
def connectDB():
    global connection,cursor
    try:
        connection = cx_Oracle.connect(LSF_DB_USER,LSF_DB_PASSWORD,LSF_DB_NAME)
        cursor = connection.cursor()
    except Exception:
        print >> stdout,'Error Connecting to the LSF database check the connection settings'
def disconnectDB():
    connection.close()

##process the Usage of the script and check command line arguments
def checkUsage():
    showhelp=True
    global command,filename,dontvalidate
    try:
        options, remainder = getopt.getopt(argv[1:], 'c:f:h:n', ['command=',                                                          
                                                          'filename=',
                                                         'help=',
                                                         'novalidate='
                                                         ])
        dontvalidate = False
        for opt, arg in options:
            if opt in ('-c', '--command'):
                command = arg
                showhelp = False                
            elif opt in ('-f', '--filename'):
                filename = arg
            elif opt in ('-n' '--novalidate'):
                dontvalidate = True
    
    except getopt.GetoptError:
        pass
    if showhelp:
        showHelp()
        return False
    else:
        return True

def showHelp():
    print >>stdout, "This script will create host or user configuration for LSF and print it to STDOUT or to file if specified";
    print >>stdout , 'USAGE: %s -c <user|USER|HOST|host> -f <filename> -n  -f switch is optional -n switch for no XML validation'  %argv[0] 
    
#print the banner for LSF configuration
def printBanner():
    header ='''#    
#     CERN LSF configuration file
# automatically generated. DO NOT EDIT 
#\n\n
'''
    return header



if __name__ == '__main__':
    main()




